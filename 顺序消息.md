### 什么是顺序消息
顺序消息指consumer端用户Listener收到消息的顺序和这些消息放的顺序是一致的，也就是Producer先发送的消息先收到。
这个一致不是指所有消息都是按照顺序排着队到达consumer，而是用用户指定哪些消息之间有顺序关系，只有有顺序关系的才是按序处理。   

### 消息保证顺序的面临的问题
实现一个先进先出FIFO队列看似简单，但是放到分布式队列里，实现起来就会很复杂。尤其是不可能为了一个顺序消息的功能而破坏了原有的架构。   
1.一条消息从Producer发送到broker的过程其实是发送到一个broker集群的，消息会被分布到多个broker的多个Queue上面。
即使发送的时候是一条一条按照顺序发送的，也不能保证消息达到Broker的时间也是按照发送的顺序来的。   

2.Broker之间是没有数据交互的，也就是说BrokerA收到一条Producer提交的消息，他并不知道之前那条消息被发送到哪个Broker的哪个Queue上，
更不用说知道之前那条消息是否消费成功了，所以依赖broker来控制消息的顺序是很困难的。  

3.为了提高并发能力，同一个Group下会有多个Consumer，每个Consumer消费一部分queue的消息。所以如果两条有顺序关系的消息分布在
两个queue上，就有可能被push到两个Consumer上，而Consumer之间也没有数据交互，依赖consumer做排序也是很难的。    

### RocketMQ顺序消息的实现原理
RocketMQ在针对顺序消息的实现上，大部分逻辑依赖客户端，也就是Producer和Consumer。Broker在整个流程中不会感知到顺序消息的存在。   
1.针对问题一，既然分散到多个broker上无法追踪顺序，RocketMQ的做法是有顺序关系的消息都发送到同一个queue上，自然他们也会存到同一个broker上。
根据broker消息的存储逻辑，同一个queue的消息，先到的肯定放在前面，所以只要客户端在发送的时候使用单线程，发送完一条再发送另一条，
消息在broker上保存的顺序自然也是按发送的顺序。   

2.针对问题二，既然Broker不知道消息的状态，那就把保证顺序这件事交给Consumer，因为第一步中有顺序关系的消息已经在同一个queue里了，
consumer拿消息的时候本来也是按照存的顺序来的，所以broker不需要做任何特殊逻辑。   

3.针对问题三，consumer需要做如下保证：   
- 一个topic下的消息会被同一个group下的多个consumer按照queue瓜分消费。而对于顺序消息，同一个queue只允许一个consumer消费。
consumer在启动后会尝试到broker获取指定的queue的锁，只有持有queue锁的consumer才能消费这个queue的消息。  
- 在普通消息模式下，消息到达consumer之后会被放进缓存队列中，然后会有多个线程同时处理队列中消息。
而对于顺序消息，consumer增加了互斥锁，同一个时间同一个queue只会有一个线程在处理。   
- 普通消息会有两种情况导致消息重新返回给broker重新投递，一种是消息在consumer的缓存中等待时间过长，
还有一种是用户代码逻辑中处理失败。而对于顺序消息，只要到达consumer会一直尝试消费，直到超过最大次数，
才会返回给broker，这时broker不会再重新投递，而且顺序消息也不会因为超时而被返还给broker。   

### 顺序消息存在的问题
- 由于需要有顺序关系的消息在发送到同一个queue中，而不是使用客户端自带的负载均衡策略，所以一旦量比较大，
可能会造成这个队列消息量很大，而其他队列比较空闲的情况。   
- 顺序消息处理必须在同一个consumer上，而且同一个queue的消息只能单线程处理，也存在消息堆积的可能。    
- 如果业务处理消息失败，只会在consumer端重试，到达重试次数之后，会直接放入broker中的死信队列。  
- 顺序消息是否100%保证消息的顺序？答案是否定的。有消息m1、m2、m3需要顺序处理，m1被发送到q1中，
这个时候q1所在的broker宕机了，Producer会另外选择一个queue来投递m2、m3，这个时候m1、m2会到达不同的consumer上。
当然这个情况发生的概率是非常低的，因为producer从检测到broker宕机到切换queue需要一段时间，
同时consumer需要有消息堆积才会造成这种情况。   

顺序消息在保证顺序的同时会放弃吞吐和一定可用性。在选用顺序消息的时候，一定是业务上必须有序的要求，
再就是尽量把顺序维持在一个很小非范围内。  

























